
using COSXML;
using COSXML.Auth;
using COSXML.CosException;
using COSXML.Model.Object;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace installer.Model
{
    public class Tencent_Cos
    {
        public string Appid { get; init; }
        public string Region { get; init; }
        public Tencent_Cos(string appid, string region)
        {

        }

        public void download(string download_dir, string key)
        {
            // download_dir标记根文件夹路径，key为相对根文件夹的路径（不带./）
            // 初始化CosXmlConfig（提供配置SDK接口）
            string appid = "1314234950";   // 设置腾讯云账户的账户标识（APPID）
            string region = "ap-beijing";  // 设置一个默认的存储桶地域
            CosXmlConfig config = new CosXmlConfig.Builder()
                                      .IsHttps(true)      // 设置默认 HTTPS 请求
                                      .SetAppid(appid)    // 设置腾讯云账户的账户标识 APPID
                                      .SetRegion(region)  // 设置一个默认的存储桶地域
                                      .SetDebugLog(true)  // 显示日志
                                      .Build();           // 创建 CosXmlConfig 对象

            // 永久密钥访问凭证
            string secretId = "***"; //"云 API 密钥 SecretId";
            string secretKey = "***"; //"云 API 密钥 SecretKey";

            long durationSecond = 1000;  // 每次请求签名有效时长，单位为秒
            QCloudCredentialProvider cosCredentialProvider = new DefaultQCloudCredentialProvider(
                secretId, secretKey, durationSecond
            );
            // 初始化 CosXmlServer
            CosXmlServer cosXml = new CosXmlServer(config, cosCredentialProvider);

            // 创建存储桶
            try
            {
                string bucket = "thuai6-1314234950";                                // 格式：BucketName-APPID
                string localDir = System.IO.Path.GetDirectoryName(download_dir)     // 本地文件夹
                    ?? throw new Exception("本地文件夹路径获取失败");
                string localFileName = System.IO.Path.GetFileName(download_dir);    // 指定本地保存的文件名
                GetObjectRequest request = new GetObjectRequest(bucket, key, localDir, localFileName);

                Dictionary<string, string> test = request.GetRequestHeaders();
                request.SetCosProgressCallback(delegate (long completed, long total)
                {
                    //Console.WriteLine(String.Format("progress = {0:##.##}%", completed * 100.0 / total));
                });
                // 执行请求
                GetObjectResult result = cosXml.GetObject(request);
                // 请求成功
            }
            catch (CosClientException clientEx)
            {
                throw clientEx;
            }
            catch (CosServerException serverEx)
            {
                throw serverEx;
            }
            catch
            {
                MessageBox.Show($"下载{download_dir}时出现未知问题，请反馈");
            }
        }

        public static void GetNewHash()
        {
            Tencent_cos_download Downloader = new Tencent_cos_download();
            Downloader.download(System.IO.Path.Combine(Data.FilePath, "hash.json"), "hash.json");
        }

        public static string GetFileMd5Hash(string strFileFullPath)
        {
            FileStream? fst = null;
            try
            {
                fst = new FileStream(strFileFullPath, FileMode.Open, FileAccess.Read);
                byte[] data = MD5.Create().ComputeHash(fst);

                StringBuilder sBuilder = new StringBuilder();

                for (int i = 0; i < data.Length; i++)
                {
                    sBuilder.Append(data[i].ToString("x2"));
                }

                fst.Close();
                return sBuilder.ToString().ToLower();
            }
            catch (Exception)
            {
                if (fst != null)
                    fst.Close();
                if (File.Exists(strFileFullPath))
                    return "conflict";
                return "";
            }
            finally
            {
            }
        }

        public static bool IsUserFile(string filename)
        {
            if (filename.Substring(filename.Length - 3, 3).Equals(".sh") || filename.Substring(filename.Length - 4, 4).Equals(".cmd"))
                return true;
            if (filename.Equals("AI.cpp") || filename.Equals("AI.py"))
                return true;
            return false;
        }

        public static UpdateInfo Check(SettingsModel.UsingOS OS)
        {
            string json, MD5, jsonName;
            int newFile = 0, updateFile = 0;
            newFileName.Clear();
            updateFileName.Clear();
            jsonName = "hash.json";
            UpdateInfo updateInfo;

            Tencent_cos_download Downloader = new Tencent_cos_download();
            try
            {
                // 如果json存在就删了重新下
                if (File.Exists(System.IO.Path.Combine(Data.FilePath, jsonName)))
                {
                    File.Delete(System.IO.Path.Combine(Data.FilePath, jsonName));
                    Downloader.download(System.IO.Path.Combine(Data.FilePath, jsonName), jsonName);
                }
                else
                {
                    Downloader.download(System.IO.Path.Combine(Data.FilePath, jsonName), jsonName);
                }
            }
            catch (CosClientException clientEx)
            {
                // 请求失败
                updateInfo.status = "ClientEx: " + clientEx.ToString();
                updateInfo.newFileCount = -1;
                updateInfo.changedFileCount = 0;
                return updateInfo;
            }
            catch (CosServerException serverEx)
            {
                // 请求失败
                updateInfo.status = "ServerEx: " + serverEx.ToString();
                updateInfo.newFileCount = -1;
                updateInfo.changedFileCount = 0;
                return updateInfo;
            }

            using (StreamReader r = new StreamReader(System.IO.Path.Combine(Data.FilePath, jsonName)))
                json = r.ReadToEnd();
            json = json.Replace("\r", string.Empty).Replace("\n", string.Empty);
            var jsonDict = Utils.DeserializeJson1<Dictionary<string, string>>(json);
            string updatingFolder = "";
            switch (OS)
            {
                case SettingsModel.UsingOS.Win:
                    updatingFolder = "THUAI6/win";
                    break;
                case SettingsModel.UsingOS.Linux:
                    updatingFolder = "THUAI6/lin";
                    break;
                case SettingsModel.UsingOS.OSX:
                    updatingFolder = "THUAI6/osx";
                    break;
            }
            foreach (KeyValuePair<string, string> pair in jsonDict)
            {
                if (pair.Key.Length > 10 && (pair.Key.Substring(0, 10).Equals(updatingFolder)) || pair.Key.Substring(pair.Key.Length - 4, 4).Equals(".pdf"))
                {
                    MD5 = GetFileMd5Hash(System.IO.Path.Combine(Data.FilePath, pair.Key.TrimStart(new char[] { '.', '/' })));
                    if (MD5.Length == 0)  // 文档不存在
                        newFileName.Enqueue(pair.Key);
                    else if (MD5.Equals("conflict"))
                    {
                        if (pair.Key.Equals("THUAI6/win/CAPI/cpp/.vs/CAPI/v17/Browse.VC.db"))
                        {
                            MessageBox.Show($"visual studio未关闭：\n" +
                            $"对于visual studio 2022，可以更新，更新会覆盖visual studio中已经打开的选手包；\n" +
                            $"若使用其他版本的visual studio是继续更新出现问题，请汇报；\n" +
                            $"若您自行修改了选手包，请注意备份；\n" +
                            $"若关闭visual studio后仍弹出，请汇报。\n\n",
                            "visual studio未关闭", MessageBoxButton.OK, MessageBoxImage.Information);
                        }
                        else
                            MessageBox.Show($"检查{pair.Key}更新时遇到问题，请反馈", "读取出错", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                    else if (!MD5.Equals(pair.Value) && !IsUserFile(System.IO.Path.GetFileName(pair.Key)))  // MD5不匹配
                        updateFileName.Enqueue(pair.Key);
                }
            }

            newFile = newFileName.Count;
            updateFile = updateFileName.Count;
            filenum = newFile + updateFile;
            //Console.WriteLine("----------------------" + Environment.NewLine);

            if (newFile + updateFile == 0)
            {
                updateInfo.status = "latest";
                updateInfo.newFileCount = 0;
                updateInfo.changedFileCount = 0;
                newFileName.Clear();
                updateFileName.Clear();
            }
            else
            {
                updateInfo.status = "old";
                //TODO:获取版本号
                updateInfo.newFileCount = newFile;
                /*
                foreach (string filename in newFileName)
                {
                    Console.WriteLine(filename);
                }
                */
                updateInfo.changedFileCount = updateFile;
                /*
                foreach (string filename in updateFileName)
                {
                    Console.WriteLine(filename);
                }
                Console.Write(Environment.NewLine + "是否下载新文件？ y/n：");
                if (Console.Read() != 'y')
                    Console.WriteLine("下载取消!");
                else
                    Download();
                */
                UpdatePlanned = true;
            }
            return updateInfo;
        }

        public static bool Update()
        {
            if (UpdatePlanned)
            {
                Download();
                if (updateFailed.Count == 0)
                    return true;
            }
            return false;
        }
        private static void Download()
        {
            Tencent_cos_download Downloader = new Tencent_cos_download();
            int newFile = 0;
            int totalnew = newFileName.Count, totalupdate = updateFileName.Count;
            filenum = totalnew + totalupdate;
            updateFailed.Clear();
            if (newFileName.Count > 0 || updateFileName.Count > 0)
            {
                try
                {
                    int cnt = newFileName.Count;
                    if (cnt <= 20)
                    {
                        while (newFileName.TryDequeue(out var filename))
                        {
                            Downloader.download(System.IO.Path.Combine(@Data.FilePath, filename), filename.TrimStart(new char[] { '.', '/' }));
                            //Console.WriteLine(filename + "下载完毕!" + Environment.NewLine);
                            Interlocked.Increment(ref newFile);
                        }
                    }
                    else
                    {
                        const int nthread = 8;
                        var thrds = new List<Thread>();
                        for (int i = 0; i < nthread; i++)
                        {
                            var thrd = new Thread(() =>
                            {
                                while (newFileName.TryDequeue(out var filename))
                                {
                                    Downloader.download(System.IO.Path.Combine(@Data.FilePath, filename), filename.TrimStart(new char[] { '.', '/' }));
                                    //Console.WriteLine(filename + "下载完毕!" + Environment.NewLine);
                                    Interlocked.Increment(ref newFile);
                                }
                            });
                            thrd.Start();
                            thrds.Add(thrd);
                        }
                        foreach (var thrd in thrds)
                        {
                            thrd.Join();
                        }
                    }
                    // 读取 Interlocked.CompareExchange(ref newFile, 0, 0);

                    int upcnt = updateFileName.Count;
                    if (upcnt <= 20)
                    {
                        while (updateFileName.TryDequeue(out var filename))
                        {
                            try
                            {
                                File.Delete(System.IO.Path.Combine(@Data.FilePath, filename));
                                Downloader.download(System.IO.Path.Combine(@Data.FilePath, filename), filename.TrimStart(new char[] { '.', '/' }));
                            }
                            catch (System.IO.IOException)
                            {
                                updateFailed = updateFailed.Append(filename).ToList();
                            }
                            catch
                            {
                                if (filename.Substring(filename.Length - 4, 4).Equals(".pdf"))
                                {
                                    MessageBox.Show($"由于曾经发生过的访问冲突，下载器无法更新{filename}\n"
                                        + $"请手动删除{filename}，然后再试一次。");
                                }
                                else
                                    MessageBox.Show($"更新{filename}时遇到未知问题，请反馈");
                                updateFailed = updateFailed.Append(filename).ToList();
                            }
                            Interlocked.Increment(ref newFile);
                        }
                    }
                    else
                    {
                        const int nthread = 8;
                        var thrds = new List<Thread>();

                        for (int i = 0; i < nthread; i++)
                        {
                            var thrd = new Thread(() =>
                            {
                                while (updateFileName.TryDequeue(out var filename))
                                {
                                    try
                                    {
                                        File.Delete(System.IO.Path.Combine(@Data.FilePath, filename));
                                        Downloader.download(System.IO.Path.Combine(@Data.FilePath, filename), filename.TrimStart(new char[] { '.', '/' }));
                                    }
                                    catch (System.IO.IOException)
                                    {
                                        updateFailed = updateFailed.Append(filename).ToList();
                                    }
                                    catch
                                    {
                                        if (filename.Substring(filename.Length - 4, 4).Equals(".pdf"))
                                        {
                                            MessageBox.Show($"由于曾经发生过的访问冲突，下载器无法更新{filename}\n"
                                                + $"请手动删除{filename}，然后再试一次。");
                                        }
                                        else
                                            MessageBox.Show($"更新{filename}时遇到未知问题，请反馈");
                                        updateFailed = updateFailed.Append(filename).ToList();
                                    }
                                    Interlocked.Increment(ref newFile);
                                }
                            });
                            thrd.Start();
                            thrds.Add(thrd);
                        }
                        foreach (var thrd in thrds)
                        {
                            thrd.Join();
                        }
                    }
                    if (updateFailed.Count == 0)
                        UpdatePlanned = false;
                }
                catch (CosClientException clientEx)
                {
                    // 请求失败
                    MessageBox.Show("连接错误:" + clientEx.ToString());
                    Console.WriteLine("CosClientException: " + clientEx.ToString() + Environment.NewLine);
                    return;
                }
                catch (CosServerException serverEx)
                {
                    // 请求失败
                    MessageBox.Show("连接错误:" + serverEx.ToString());
                    Console.WriteLine("CosClientException: " + serverEx.ToString() + Environment.NewLine);
                    return;
                }
                catch (Exception)
                {
                    MessageBox.Show("未知错误且无法定位到出错文件，请反馈");
                    throw;
                }
            }
            else
                Console.WriteLine("当前平台已是最新版本！" + Environment.NewLine);
            newFileName.Clear();
            updateFileName.Clear();
        }

        public static bool CheckAlreadyDownload()  // 检查是否已经下载
        {
            string existpath = System.IO.Path.Combine(Data.dataPath, "THUAI6.json");
            if (!File.Exists(existpath))  // 文件不存在
            {
                using FileStream fs = new FileStream(existpath, FileMode.Create, FileAccess.ReadWrite);
                return false;
            }
            else  // 文件存在
            {
                using FileStream fs = new FileStream(existpath, FileMode.Open, FileAccess.Read);
                using StreamReader sr = new StreamReader(fs);
                string json = sr.ReadToEnd();
                if (json == null || json == "")
                {
                    json += @"{""THUAI6""" + ":" + @"""2023""}";
                }
                var dict = Utils.TryDeserializeJson<Dictionary<string, string>>(json);
                if (dict == null || !dict.ContainsKey("download") || "false" == dict["download"])
                {
                    return false;
                }
                else if (dict["download"] == "true")
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        public static void DownloadAll()  // 下载全部文件
        {
            string jsonName = "hash.json";
            string json;
            Tencent_cos_download Downloader = new Tencent_cos_download();

            try
            {
                // 如果json存在就删了重新下
                if (File.Exists(System.IO.Path.Combine(Data.FilePath, jsonName)))
                {
                    File.Delete(System.IO.Path.Combine(Data.FilePath, jsonName));
                    Downloader.download(System.IO.Path.Combine(Data.FilePath, jsonName), jsonName);
                }
                else
                {
                    Downloader.download(System.IO.Path.Combine(Data.FilePath, jsonName), jsonName);
                }
            }
            catch (CosClientException clientEx)
            {
                // 请求失败
                Console.WriteLine("CosClientException: " + clientEx.ToString() + Environment.NewLine);
                return;
            }
            catch (CosServerException serverEx)
            {
                // 请求失败
                Console.WriteLine("CosClientException: " + serverEx.ToString() + Environment.NewLine);
                return;
            }
            using (StreamReader r = new StreamReader(System.IO.Path.Combine(Data.FilePath, jsonName)))
                json = r.ReadToEnd();
            json = json.Replace("\r", string.Empty).Replace("\n", string.Empty);
            // var jsonDict = Utils.DeserializeJson<Dictionary1<string, string>>(json);

            newFileName.Clear();
            updateFileName.Clear();
            newFileName.Enqueue("THUAI6.tar.gz");
            Download();
            Stream? inStream = null;
            Stream? gzipStream = null;
            TarArchive? tarArchive = null;
            try
            {
                using (inStream = File.OpenRead(System.IO.Path.Combine(Data.FilePath, "THUAI6.tar.gz")))
                {
                    using (gzipStream = new GZipInputStream(inStream))
                    {
                        tarArchive = TarArchive.CreateInputTarArchive(gzipStream);
                        tarArchive.ExtractContents(Data.FilePath);
                        tarArchive.Close();
                    }
                }
            }
            catch
            {
                //出错
            }
            finally
            {
                if (null != tarArchive) tarArchive.Close();
                if (null != gzipStream) gzipStream.Close();
                if (null != inStream) inStream.Close();
            }
            FileInfo fileInfo = new FileInfo(System.IO.Path.Combine(Data.FilePath, "THUAI6.tar.gz"));
            fileInfo.Delete();
            string json2;
            Dictionary<string, string>? dict;
            string existpath = System.IO.Path.Combine(Data.dataPath, "THUAI6.json");
            using FileStream fs = new FileStream(existpath, FileMode.Open, FileAccess.ReadWrite);
            using (StreamReader r = new StreamReader(fs))
            {
                json2 = r.ReadToEnd();
                if (json2 == null || json2 == "")
                {
                    json2 += @"{""THUAI6""" + ":" + @"""2023""}";
                }
                dict = Utils.TryDeserializeJson<Dictionary<string, string>>(json2);
                if (dict == null || !dict.ContainsKey("download"))
                {
                    dict?.Add("download", "true");
                }
                else
                {
                    dict["download"] = "true";
                }
            }

            using FileStream fs2 = new FileStream(existpath, FileMode.Open, FileAccess.ReadWrite);
            using StreamWriter sw = new StreamWriter(fs2);
            fs2.SetLength(0);
            sw.Write(JsonConvert.SerializeObject(dict));
            Check(SettingsModel.UsingOS.Win);
            Download();
            if (File.Exists(Data.FilePath + "/THUAI6/AI.cpp"))
            {
                FileInfo userCpp = new FileInfo((Data.FilePath + "/THUAI6/AI.cpp").Replace("/", "\\"));
                userCpp.MoveTo(Data.FilePath + "/THUAI6/win/CAPI/cpp/API/src/AI.cpp", true);
            }
            if (File.Exists(Data.FilePath + "/THUAI6/AI.py"))
            {
                FileInfo userCpp = new FileInfo((Data.FilePath + "/THUAI6/AI.py").Replace("/", "\\"));
                userCpp.MoveTo(Data.FilePath + "/THUAI6/win/CAPI/python/PyAPI/AI.cpp", true);
            }
        }

        public static void Change_all_hash(string topDir, Dictionary<string, string> jsonDict)  // 更改HASH
        {
            DirectoryInfo theFolder = new DirectoryInfo(@topDir);
            bool ifexist = false;

            // 遍历文件
            foreach (FileInfo NextFile in theFolder.GetFiles())
            {
                string filepath = topDir + @"/" + NextFile.Name;  // 文件路径
                                                                  //Console.WriteLine(filepath);
                foreach (KeyValuePair<string, string> pair in jsonDict)
                {
                    if (System.IO.Path.Equals(filepath, System.IO.Path.Combine(Data.FilePath, pair.Key).Replace('\\', '/')))
                    {
                        ifexist = true;
                        string MD5 = GetFileMd5Hash(filepath);
                        jsonDict[pair.Key] = MD5;
                    }
                }
                if (!ifexist && NextFile.Name != "hash.json")
                {
                    string MD5 = GetFileMd5Hash(filepath);
                    string relapath = filepath.Replace(Data.FilePath + '/', string.Empty);
                    jsonDict.Add(relapath, MD5);
                }
                ifexist = false;
            }

            // 遍历文件夹
            foreach (DirectoryInfo NextFolder in theFolder.GetDirectories())
            {
                if (System.IO.Path.Equals(NextFolder.FullName, System.IO.Path.GetFullPath(System.IO.Path.Combine(Data.FilePath, playerFolder))))
                {
                    foreach (FileInfo NextFile in NextFolder.GetFiles())
                    {
                        if (NextFile.Name == "AI.cpp" || NextFile.Name == "AI.py")
                        {
                            string MD5 = GetFileMd5Hash(NextFile.FullName);
                            string relapath = NextFile.FullName.Replace('\\', '/').Replace(Data.FilePath + '/', string.Empty);
                            jsonDict.Add(relapath, MD5);
                        }
                    }
                    continue;  // 如果是选手文件夹就忽略
                }
                Change_all_hash(NextFolder.FullName.Replace('\\', '/'), jsonDict);
            }
        }
        public static void UpdateHash()
        {
            while (true)
            {
                if (Directory.Exists(Data.FilePath))
                {
                    string json;
                    if (!File.Exists(System.IO.Path.Combine(Data.FilePath, "hash.json")))
                    {
                        Console.WriteLine("hash.json文件丢失！即将重新下载该文件！");
                        GetNewHash();
                    }
                    using (StreamReader r = new StreamReader(System.IO.Path.Combine(Data.FilePath, "hash.json")))
                        json = r.ReadToEnd();
                    json = json.Replace("\r", string.Empty).Replace("\n", string.Empty).Replace("/", @"\\");
                    Dictionary<string, string> jsonDict = Utils.DeserializeJson1<Dictionary<string, string>>(json);
                    Change_all_hash(Data.FilePath, jsonDict);
                    OverwriteHash(jsonDict);
                    break;
                }
                else
                {
                    Console.WriteLine("读取路径失败！请重新输入文件路径：");
                    Data.ResetFilepath(Console.ReadLine() ?? "");
                }
            }
        }

        public static int DeleteAll()
        {
            DirectoryInfo di = new DirectoryInfo(Data.FilePath + "/THUAI6");
            //DirectoryInfo player = new DirectoryInfo(System.IO.Path.GetFullPath(System.IO.Path.Combine(Data.FilePath, playerFolder)));
            FileInfo[] allfile = di.GetFiles();
            try
            {
                foreach (FileInfo file in allfile)
                {
                    //if(file.Name == "AI.cpp" || file.Name == "AI.py")
                    //{
                    //    string filename = System.IO.Path.GetFileName(file.FullName);
                    //    file.MoveTo(System.IO.Path.Combine(Data.FilePath, filename));
                    //    continue;
                    //}
                    file.Delete();
                }
                FileInfo userFileCpp = new FileInfo(Data.FilePath + "/THUAI6/win/CAPI/cpp/API/src/AI.cpp");
                FileInfo userFilePy = new FileInfo(Data.FilePath + "/THUAI6/win/CAPI/python/PyAPI/AI.py");
                userFileCpp.MoveTo(System.IO.Path.Combine(Data.FilePath + "/THUAI6", System.IO.Path.GetFileName(userFileCpp.FullName)));
                userFilePy.MoveTo(System.IO.Path.Combine(Data.FilePath + "/THUAI6", System.IO.Path.GetFileName(userFilePy.FullName)));
                foreach (DirectoryInfo subdi in di.GetDirectories())
                {
                    subdi.Delete(true);
                }
                FileInfo hashFile = new FileInfo(Data.FilePath + "/hash.json");
                hashFile.Delete();
            }
            catch (UnauthorizedAccessException)
            {
                Console.WriteLine("权限不足，无法删除！");
                return -2;
            }
            catch (DirectoryNotFoundException)
            {
                Console.WriteLine("文件夹没有找到，请检查是否已经手动更改路径");
                return -3;
            }
            catch (IOException)
            {
                Console.WriteLine("文件已经打开，请关闭后再删除");
                return -1;
            }

            string json2;
            Dictionary<string, string>? dict;
            string existpath = System.IO.Path.Combine(Data.dataPath, "THUAI6.json");
            using FileStream fs = new FileStream(existpath, FileMode.Open, FileAccess.ReadWrite);
            using (StreamReader r = new StreamReader(fs))
            {
                json2 = r.ReadToEnd();
                if (json2 == null || json2 == "")
                {
                    json2 += @"{""THUAI6""" + ":" + @"""2023""}";
                }
                dict = Utils.TryDeserializeJson<Dictionary<string, string>>(json2);
                if (dict == null || !dict.ContainsKey("download"))
                {
                    dict?.Add("download", "false");
                }
                else
                {
                    dict["download"] = "false";
                }
            }
            using FileStream fs2 = new FileStream(existpath, FileMode.Open, FileAccess.ReadWrite);
            using StreamWriter sw = new StreamWriter(fs2);
            fs2.SetLength(0);
            sw.Write(JsonConvert.SerializeObject(dict));
            sw.Close();
            fs2.Close();
            try
            {
                File.Delete(Data.path);
            }
            catch (UnauthorizedAccessException)
            {
                Console.WriteLine("权限不足，无法删除！");
                return -2;
            }
            catch (DirectoryNotFoundException)
            {
                Console.WriteLine("文件夹没有找到，请检查是否已经手动更改路径");
                return -3;
            }
            catch (IOException)
            {
                Console.WriteLine("文件已经打开，请关闭后再删除");
                return -1;
            }
            return 0;
        }

        public static void OverwriteHash(Dictionary<string, string> jsonDict)
        {
            string Contentjson = JsonConvert.SerializeObject(jsonDict);
            Contentjson = Contentjson.Replace("\r", String.Empty).Replace("\n", String.Empty).Replace(@"\\", "/");
            File.WriteAllText(@System.IO.Path.Combine(Data.FilePath, "hash.json"), Contentjson);
        }

        public static int MoveProgram(string newPath)
        {
            DirectoryInfo newdi = new DirectoryInfo(newPath + "/THUAI6");
            DirectoryInfo olddi = new DirectoryInfo(Data.FilePath + "/THUAI6");
            try
            {
                if (!Directory.Exists(newPath + "/THUAI6"))
                    Directory.CreateDirectory(newPath + "/THUAI6");
                foreach (DirectoryInfo direct in olddi.GetDirectories())
                {
                    direct.MoveTo(System.IO.Path.Combine(newPath + "/THUAI6", direct.Name));
                }
                foreach (FileInfo file in olddi.GetFiles())
                {
                    file.MoveTo(System.IO.Path.Combine(newPath + "/THUAI6", file.Name));
                }
                olddi.Delete();
            }
            catch (DirectoryNotFoundException)
            {
                Console.WriteLine("原路径未找到！请检查文件是否损坏");
                if (newdi.GetDirectories().Length != 0)
                {
                    foreach (DirectoryInfo newdirect in newdi.GetDirectories())
                    {
                        newdirect.MoveTo(System.IO.Path.Combine(Data.FilePath + "/THUAI6", newdirect.Name));
                    }
                }
                if (newdi.GetFiles().Length != 0)
                {
                    foreach (FileInfo file in newdi.GetFiles())
                    {
                        file.MoveTo(System.IO.Path.Combine(Data.FilePath + "/THUAI6", file.Name));
                    }
                }
                Console.WriteLine("移动失败！");
                if (newdi.Exists)
                    newdi.Delete();
                return -2;
            }
            catch (IOException)
            {
                Console.WriteLine("文件已打开或者目标路径下有同名文件！");
                if (newdi.GetDirectories().Length != 0)
                {
                    foreach (DirectoryInfo newdirect in newdi.GetDirectories())
                    {
                        newdirect.MoveTo(System.IO.Path.Combine(Data.FilePath + "/THUAI6", newdirect.Name));
                    }
                }
                if (newdi.GetFiles().Length != 0)
                {
                    foreach (FileInfo file in newdi.GetFiles())
                    {
                        file.MoveTo(System.IO.Path.Combine(Data.FilePath + "/THUAI6", file.Name));
                    }
                }
                if (newdi.Exists)
                    newdi.Delete();
                Console.WriteLine("移动失败！");
                return -1;
            }
            FileInfo hashFile = new FileInfo(Data.FilePath + "/hash.json");
            hashFile.MoveTo(newPath + "/hash.json");
            Data.ResetFilepath(newPath);
            Console.WriteLine("更改路径成功!");
            return 0;
        }
        public static async Task main(string[] args)
        {
            var client = new HttpClient();
            var web = new WebConnect.Web();
            Data date = new Data("");
            while (true)
            {
                Console.WriteLine($"1. 更新hash.json   2. 检查更新   3.下载{ProgramName}  4.删除{ProgramName}  5.启动进程  6.移动{ProgramName}到其它路径");
                string choose = Console.ReadLine() ?? "";
                if (choose == "1")
                {
                    if (!CheckAlreadyDownload())
                    {
                        Console.WriteLine($"未下载{ProgramName}，请先执行下载操作！");
                        continue;
                    }
                    UpdateHash();
                }
                else if (choose == "2")
                {
                    if (!CheckAlreadyDownload())
                    {
                        Console.WriteLine($"未下载{ProgramName}，请先执行下载操作！");
                        continue;
                    }
                    while (true)
                    {
                        if (Data.FilePath != null && Directory.Exists(Data.FilePath))
                        {
                            Check(SettingsModel.UsingOS.Win);
                            break;
                        }
                        else
                        {
                            Console.WriteLine("读取路径失败！请重新输入文件路径：");
                            Data.ResetFilepath(Console.ReadLine() ?? "");
                        }
                    }
                }
                else if (choose == "3")
                {
                    if (CheckAlreadyDownload())
                    {
                        Console.WriteLine($"已经将{ProgramName}下载到{Data.FilePath}！若要重新下载请先完成删除操作！");
                    }
                    else
                    {
                        string newpath;
                        Console.WriteLine("请输入下载路径：");
                        newpath = Console.ReadLine() ?? "";
                        Data.ResetFilepath(newpath);
                        DownloadAll();
                    }
                }
                else if (choose == "4")
                {
                    DeleteAll();
                }
                else if (choose == "5")
                {
                    if (CheckAlreadyDownload())
                    {
                        Process.Start(System.IO.Path.Combine(Data.FilePath, startName));
                    }
                    else
                    {
                        Console.WriteLine($"未下载{ProgramName}，请先执行下载操作！");
                    }
                }
                else if (choose == "6")
                {
                    string newPath;
                    newPath = Console.ReadLine() ?? "";
                    MoveProgram(newPath);
                }
                else if (choose == "7")
                {
                    Console.WriteLine("请输入email：");
                    string username = Console.ReadLine() ?? "";
                    Console.WriteLine("请输入密码：");
                    string password = Console.ReadLine() ?? "";

                    await web.LoginToEEsast(client, username, password);
                }
                else if (choose == "8")
                {
                    await web.UserDetails(client);
                }
                else if (choose == "9")
                {
                    await web.UploadFiles(client, "", "", "");
                }
                else if (choose == "exit")
                {
                    return;
                }
            }
        }

        public static int CheckSelfVersion()
        {
            string keyHead = "Installer/";
            Tencent_cos_download downloader = new Tencent_cos_download();
            string hashName = "installerHash.json";
            string dir = System.IO.Path.GetDirectoryName(System.Diagnostics.Process.GetCurrentProcess().MainModule?.FileName)
                ?? throw new Exception("Failed to get current directory");
            int result = 0;
            try
            {
                if (File.Exists(System.IO.Path.Combine(dir, hashName)))
                    File.Delete(System.IO.Path.Combine(dir, hashName));
                downloader.download(System.IO.Path.Combine(dir, hashName), hashName);
            }
            catch
            {
                return -1;
            }
            string json;
            using (StreamReader r = new StreamReader(System.IO.Path.Combine(dir, hashName)))
                json = r.ReadToEnd();
            json = json.Replace("\r", string.Empty).Replace("\n", string.Empty);
            var jsonDict = Utils.TryDeserializeJson<Dictionary<string, string>>(json);
            string md5 = "";
            List<string> awaitUpdate = new List<string>();
            if (jsonDict != null)
            {
                foreach (KeyValuePair<string, string> pair in jsonDict)
                {
                    md5 = GetFileMd5Hash(System.IO.Path.Combine(dir, pair.Key));
                    if (md5.Length == 0)  // 文档不存在
                    {
                        downloader.download(System.IO.Path.Combine(dir, pair.Key), keyHead + pair.Key);
                    }
                    else if (md5.Equals("conflict"))
                    {
                        MessageBox.Show($"检查{pair.Key}更新时遇到问题，请反馈", "读取出错", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                    else if (md5 != pair.Value)  // MD5不匹配
                    {
                        if (pair.Key.Substring(0, 12).Equals("InstallerUpd"))
                        {
                            File.Delete(System.IO.Path.Combine(dir, pair.Key));
                            downloader.download(System.IO.Path.Combine(dir, pair.Key), keyHead + pair.Key);
                        }
                        else
                        {
                            result = 1;
                            awaitUpdate = awaitUpdate.Append(pair.Key).ToList();
                        }
                    }
                }
            }
            else
                return -1;
            string Contentjson = JsonConvert.SerializeObject(awaitUpdate);
            Contentjson = Contentjson.Replace("\r", String.Empty).Replace("\n", String.Empty).Replace(@"\\", "/");
            File.WriteAllText(@System.IO.Path.Combine(dir, "updateList.json"), Contentjson);
            return result;
        }

        static public bool SelfUpdateDismissed()
        {
            string json;
            string dir = System.IO.Path.GetDirectoryName(System.Diagnostics.Process.GetCurrentProcess().MainModule?.FileName)
                ?? throw new Exception("Failed to get directory!");
            if (!File.Exists(System.IO.Path.Combine(dir, "updateList.json")))
                return false;
            using (StreamReader r = new StreamReader(System.IO.Path.Combine(dir, "updateList.json")))
                json = r.ReadToEnd();
            json = json.Replace("\r", string.Empty).Replace("\n", string.Empty);
            List<string>? jsonList;
            if (json != null)
                jsonList = Utils.TryDeserializeJson<List<string>>(json);
            else
                return false;
            if (jsonList != null && jsonList.Contains("Dismiss"))
            {
                listJsonClear(System.IO.Path.Combine(dir, "updateList.json"));
                return true;
            }
            return false;
        }

        static private void listJsonClear(string directory)
        {
            List<string> list = new List<string>();
            list.Add("None");
            StreamWriter sw = new StreamWriter(directory, false);
            sw.WriteLine(JsonConvert.SerializeObject(list));
            sw.Close();
        }
    }

}
